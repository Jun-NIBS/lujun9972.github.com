<!DOCTYPE html>
<html lang="en">
<head>
  <title>如何编写EmacsScript - 暗无天日</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <meta name="author" content="lujun9972" />
  <style>
   #ds-thread #ds-reset .ds-comment-body p {color: #ffffff;}
   #ds-thread #ds-reset .ds-comment-body p a {color: #ff0;}
   #ds-thread #ds-reset .ds-comment-body p a:hover {color: #0ff;}
   #disqus_thread a {color: #00ffff;}
  </style>
  <link rel="stylesheet" href="https://lujun9972.github.io/media/css/main.css" type="text/css"/>
  <link rel="stylesheet" href="https://lujun9972.github.io/media/css/comment.css" type="text/css"/>
</head>

  <body><div class="container">
    <div>
      <header class="masthead">
        <h1 class="masthead-title"><a href="https://lujun9972.github.io/">暗无天日</a> <span class="subtitle">=============&gt;随便,谢谢</span></h1>
        <ul>
          <li><a href="https://lujun9972.github.io/years/">Years</a></li>
          <li><a href="https://lujun9972.github.io/authors/">Authors</a></li>
          <li><a href="https://lujun9972.github.io/tags/">Tags</a></li>
          <li><a href="https://lujun9972.github.io/about/">About</a></li>
          <li><a href="https://github.com/lujun9972/lujun9972.github.com">Github</a></li>
          <li><a href="https://lujun9972.github.io/rss.xml">RSS</a></li>
        </ul>
        <form method="get" id="searchform" action="http://www.google.com/search">
          <input type="text" class="field" name="q" id="s" placeholder="Search">
          <input type="hidden" name="as_sitesearch" value="lujun9972.github.io">
        </form>
      </header>
    </div>

<div>
<div class="post">
<h1 class="title">如何编写EmacsScript</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgcb8305a">1. &#x2013;script选项</a></li>
<li><a href="#org3d2bcf2">2. 处理命令行参数</a></li>
<li><a href="#orga016b0d">3. EmacsScript的执行顺序</a></li>
<li><a href="#org8bd52d0">4. 标准输出,标准错误与标准输入</a></li>
<li><a href="#orgca54b61">5. 获取外部命令的运行结果</a></li>
<li><a href="#org92fc959">6. 加速EmacsScript的启动过程</a></li>
</ul>
</div>
</div>
<p>
Emacs作为一款文本编辑器已经为大家所熟知,但是可能比较少人会想到它还能用来像python,ruby一样作为一门脚本语言来用.
</p>

<p>
注意: EmacsScript的坑超级多,强烈推荐阅读这篇文章:<a href="http://www.lunaryorn.com/posts/emacs-script-pitfalls.html">emacs-script-pitfalls</a> (这里是它的中文版<a href="https://github.com/lujun9972/emacs-document/blob/master/elisp-common/emacs-script%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91.org">emacs-script中的那些坑</a>)
</p>

<div id="outline-container-orgcb8305a" class="outline-2">
<h2 id="orgcb8305a"><span class="section-number-2">1</span> &#x2013;script选项</h2>
<div class="outline-text-2" id="text-1">
<p>
Emacs提供了一个 <code>--script</code> 选项可以让Emacs运行在batch模式下,并运行指定文件中的elisp代码. 
</p>

<p>
在batch模式下emacs完全作为一个elisp语言解释器来运行,并在执行完所有的elisp代码后直接退出. 在elisp代码执行期间,那些输出到echo area中的内容会输出到stdout或stderr中,那些从minibuffer读取内容的函数会变成从stdin读取内容.
</p>

<p>
Emacs为了遵循shell script的shebang标准,特意将第一行内容中的的 <code>#!</code> 当成注释符号来处理,因此你的EmacsScript一般会是这样的:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #2aa1ae; background-color: #292e34;">#</span><span style="color: #2aa1ae; background-color: #292e34;">!/usr/bin/</span><span style="color: #4f97d7; font-weight: bold;">emacs</span><span style="color: #2aa1ae; background-color: #292e34;"> --script</span>
<span style="color: #4f97d7;">(</span>message <span style="color: #2d9574;">"Hello world"</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
当然,这种写法并不具有可移植性的,毕竟不是所有的emacs路径都是 <code>/usr/bin/emacs</code>. 真正具有可移植性的写法应该是:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">#!/bin/sh
<span style="color: #2d9574;">":"</span><span style="color: #2aa1ae; background-color: #292e34;">; </span><span style="color: #2aa1ae; background-color: #292e34;">exec emacs --quick --script "$0" -- "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-</span>
<span style="color: #4f97d7;">(</span>message <span style="color: #2d9574;">"Hello world"</span><span style="color: #4f97d7;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org3d2bcf2" class="outline-2">
<h2 id="org3d2bcf2"><span class="section-number-2">2</span> 处理命令行参数</h2>
<div class="outline-text-2" id="text-2">
<p>
注意:对于EmacsScript来说,参数与选项是截然不同的两个东西. 而且选项不能放在参数最后,否则Emacs会提示"emacs: Option '-f' requires an argument"
</p>

<p>
在EmacsLisp中,与处理命令行参数有关的常用变量有这么几个:
</p>

<ul class="org-ul">
<li><p>
command-line-args-left
</p>

<p>
尚未处理的command-line argument列表. 
</p>

<p>
假设有这么一个"/tmp/test1.el"的脚本:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">#!/bin/sh
<span style="color: #2d9574;">":"</span><span style="color: #2aa1ae; background-color: #292e34;">; </span><span style="color: #2aa1ae; background-color: #292e34;">exec emacs --script "$0" "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-</span>
<span style="color: #4f97d7;">(</span>princ <span style="color: #bc6ec5;">(</span>format <span style="color: #2d9574;">"command-line-args-left=%s"</span> command-line-args-left<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
那么执行该脚本的结果是:
</p>
<div class="org-src-container">
<pre class="src src-sh">/tmp/test1.el a b c
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">
</pre>
</div></li>

<li><p>
command-line-args
</p>

<p>
传递给Emacs的完整command-line argument列表,但是这个变量一般很少用,但它可以用于获取script脚本本身的名字.
</p>

<p>
假设有这么一个"/tmp/test2.el"的脚本:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">#!/bin/sh
<span style="color: #2d9574;">":"</span><span style="color: #2aa1ae; background-color: #292e34;">; </span><span style="color: #2aa1ae; background-color: #292e34;">exec emacs --script "$0" "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-</span>
<span style="color: #4f97d7;">(</span>princ <span style="color: #bc6ec5;">(</span>format <span style="color: #2d9574;">"command-line-args=%s\n"</span> command-line-args<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>princ <span style="color: #bc6ec5;">(</span>format <span style="color: #2d9574;">"$0=%s"</span> <span style="color: #2d9574;">(</span>nth <span style="color: #a45bad;">2</span> command-line-args<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
那么执行该脚本的结果是:
</p>
<div class="org-src-container">
<pre class="src src-sh">/tmp/test2.el a b c
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">
</pre>
</div>

<p>
可以用 <code>(nth 2 command-line-args)</code> 来获取脚本名称.
</p></li>

<li><p>
command-switch-alist
</p>

<p>
Emacs在执行完EmacsScript中的语句之后,会检查 <code>command-line-args-left</code> 中是否包含有以 <code>-</code> 开头的选项,并在该变量中查找并运行对应的handler-function. 每处理完一个选项之后,就将该参数从 <code>command-line-args-left</code> 中删除掉.
</p>

<p>
该变量是元素为`(option . handler-function)'的alist. 这里
</p>

<ul class="org-ul">
<li>option为command-line argument中的`-option'参数(<b>带-</b>),为字符串格式</li>

<li>handler-function为相应的处理函数名,它接收option为唯一参数</li>
</ul>

<p>
若command line option后还带了其他参数,则在handler-function中可以通过变量`command-line-args-left'来获取剩余的命令行参数.
</p>

<p>
例如有这么一个脚本:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">#!/bin/sh
<span style="color: #2d9574;">":"</span><span style="color: #2aa1ae; background-color: #292e34;">; </span><span style="color: #2aa1ae; background-color: #292e34;">exec emacs --script "$0" "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-</span>
<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">defun</span> <span style="color: #bc6ec5; font-weight: bold;">print-option-value</span> <span style="color: #bc6ec5;">(</span>option<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>princ <span style="color: #2d9574;">(</span>format <span style="color: #2d9574;">"command-line-args-left=%s\n"</span> command-line-args-left<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>princ <span style="color: #2d9574;">(</span>format <span style="color: #2d9574;">"value of %s is %s\n"</span> option <span style="color: #67b11d;">(</span>car command-line-args-left<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">pop</span> command-line-args-left<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7;">(</span>add-to-list 'command-switch-alist '<span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">"-f"</span> . print-option-value<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>

</pre>
</div>

<p>
那么执行该脚本的结果是:
</p>
<div class="org-src-container">
<pre class="src src-sh">/tmp/test3.el a -f filename b c
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">
</pre>
</div></li>

<li><p>
command-line-functions
</p>

<p>
该变量是一系列函数的列表,这些函数用来处理无法识别的command-line参数.
</p>

<p>
每次处理一个没有特殊意义的command line argument时,该变量中的函数都会被依次调用, <b>直到有一个函数返回非nil的值</b>
</p>

<p>
<b>这些函数被调用时并不传递参数,但在这些函数内可以通过变量`argi'获取当前待处理的command-line argument. 可以通过变量`command-line-args-left'获取尚未被处理的command line arguments</b>. 
</p>

<p>
<b>若某函数除了当前待处理的函数,同时也把后面的参数給处理过了,则需要把后面那些被处理过的参数从`command-line-args-left'中删除</b>
</p>

<p>
<b>若某函数已经处理了当前代处理的参数,则一定记得返回非nil值</b>. <b>若所有的函数都返回nil,该参数会被认为是Emacs要打开的文件名称</b>
</p>

<p>
例如有这么一个脚本:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">#!/bin/sh
<span style="color: #2d9574;">":"</span><span style="color: #2aa1ae; background-color: #292e34;">; </span><span style="color: #2aa1ae; background-color: #292e34;">exec emacs --script "$0" "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-</span>
<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">defun</span> <span style="color: #bc6ec5; font-weight: bold;">print-option</span> <span style="color: #bc6ec5;">()</span>
  <span style="color: #bc6ec5;">(</span>princ <span style="color: #2d9574;">(</span>format <span style="color: #2d9574;">"command-line-args-left=%s\n"</span> command-line-args-left<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>princ <span style="color: #2d9574;">(</span>format <span style="color: #2d9574;">"option is %s\n"</span> argi<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7;">(</span>add-to-list 'command-line-functions  #'print-option<span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
那么执行该脚本的结果是:
</p>
<div class="org-src-container">
<pre class="src src-sh">/tmp/test4.el a -p filename b
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">
</pre>
</div>

<p>
我们可以在脚本中同时使用 <code>command-switch-alist</code> 与 <code>command-line-functions</code>. 它们的调用顺序是按照传递给EmacsScript的参数顺序来进行的.
</p>

<p>
例如有这么一个脚本:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">#!/bin/sh
<span style="color: #2d9574;">":"</span><span style="color: #2aa1ae; background-color: #292e34;">; </span><span style="color: #2aa1ae; background-color: #292e34;">exec emacs --script "$0" "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-</span>
<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">defun</span> <span style="color: #bc6ec5; font-weight: bold;">print-option</span> <span style="color: #bc6ec5;">()</span>
  <span style="color: #bc6ec5;">(</span>princ <span style="color: #2d9574;">(</span>format <span style="color: #2d9574;">"option is %s\n"</span> argi<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>add-to-list 'command-line-functions  #'print-option<span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">defun</span> <span style="color: #bc6ec5; font-weight: bold;">print-option-value</span> <span style="color: #bc6ec5;">(</span>option<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>princ <span style="color: #2d9574;">(</span>format <span style="color: #2d9574;">"value of option %s is %s\n"</span> option <span style="color: #67b11d;">(</span><span style="color: #4f97d7; font-weight: bold;">pop</span> command-line-args-left<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>add-to-list 'command-switch-alist '<span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">"-f"</span> . print-option-value<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
那么执行该脚本的结果会是:
</p>
<div class="org-src-container">
<pre class="src src-sh">/tmp/test5.el a -f f -p p
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-orga016b0d" class="outline-2">
<h2 id="orga016b0d"><span class="section-number-2">3</span> EmacsScript的执行顺序</h2>
<div class="outline-text-2" id="text-3">
<p>
从上面命令行参数的说明中,大致可以推断出EmacsScript的执行顺序为:
</p>

<ol class="org-ol">
<li>Emacs读取并执行EmacsScript中的内容</li>
<li>Emacs遍历 <code>command-line-args-left</code> 中的参数,对于 <code>command-switch-alist</code> 中的参数调用对应的函数,对于不在 <code>command-switch-alist</code> 中的参数依次调用 <code>command-line-functions</code> 中的函数</li>
<li>倘若 <code>command-line-functiions</code> 中没有定义函数,或者某参数在依次调用 <code>command-line-functions</code> 中的函数后所有函数都返回nil的话,那么该参数交由emacs本身处理.</li>
</ol>
</div>
</div>

<div id="outline-container-org8bd52d0" class="outline-2">
<h2 id="org8bd52d0"><span class="section-number-2">4</span> 标准输出,标准错误与标准输入</h2>
<div class="outline-text-2" id="text-4">
<p>
在interactive模式下编写EmacsLisp函数时,我们习惯于用 <code>message</code> 函数来输出内容,然而在batch模式下,我们就不能再用 <code>message</code> 来输出内容了,因为 <code>message</code> 实际上会把内容输出到stderr上.
</p>

<p>
作为替代,若是要想将内容输出到stdout,你需要使用 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Output-Functions.html#index-print">print</a>, <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Output-Functions.html#index-prin1">prin1</a>, <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Output-Functions.html#index-princ">princ</a> 等这一系列的函数来输出内容. 然而这一类的函数本身并没有格式化输出的功能,因此你一般还需要用 <code>format</code> 函数预先将要输出的内容格式化成字符串.
</p>

<p>
那么如何从标准输入读取内容呢? 只需要跟interactive模式下一样使用 <code>read-xxx</code> 系列函数就行了. 在batch模式下,原先从minbuffer读取内容的函数会改成从stdin中读取内容.
</p>

<p>
唯一需要注意的是:Emacs24及其之前的版本的Emacs在batch模式下用 <code>read-passwd</code> 从标准输出读取密码时,会在终端上显示出密码的内容. Emacs25版本的 <code>read-passwd</code> 则解决了这个问题.
</p>
</div>
</div>

<div id="outline-container-orgca54b61" class="outline-2">
<h2 id="orgca54b61"><span class="section-number-2">5</span> 获取外部命令的运行结果</h2>
<div class="outline-text-2" id="text-5">
<p>
在shell编程中,可以使用 <code>$()</code> 来捕获命令的运行结果, EmacsScript不支持这种语法,但可以通过函数 <code>shell-command-to-string</code> 来代替. 比如
</p>

<p>
假设有这么一个脚本:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">#!/bin/sh
<span style="color: #2d9574;">":"</span><span style="color: #2aa1ae; background-color: #292e34;">; </span><span style="color: #2aa1ae; background-color: #292e34;">exec emacs --script "$0" "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-</span>
<span style="color: #4f97d7;">(</span>princ <span style="color: #2d9574;">"&#25429;&#33719;ls&#30340;&#20869;&#23481;:\n"</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>princ <span style="color: #bc6ec5;">(</span>shell-command-to-string <span style="color: #2d9574;">"ls -l"</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
那么执行该脚本的结果是:
</p>
<div class="org-src-container">
<pre class="src src-sh">/tmp/test6.el
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">
</pre>
</div>

<p>
当然,如果你愿意,完全可以使用底层的 <code>call-process</code> 与 <code>start-process</code>,这两个函数能让你更细致地控制子进程.
</p>
</div>
</div>

<div id="outline-container-org92fc959" class="outline-2">
<h2 id="org92fc959"><span class="section-number-2">6</span> 加速EmacsScript的启动过程</h2>
<div class="outline-text-2" id="text-6">
<p>
<code>--script</code> 选项会阻止Emacs启动时加载用户的初始化文件,但是依然会加载global site初始化文件.
</p>

<p>
若因此而拖慢了EmacsScript的启动速度,那么可以考虑添加 <code>--quick</code> 选项来明确禁止global site的初始化.
</p>
</div>
</div>

</div>
</div>
<div>
        <div class="post-meta">
            <span title="post date" class="post-info">2016-11-28</span>
            <span title="last modification date" class="post-info">2017-01-09</span>
            <span title="tags" class="post-info">:N/A:</span>
            <span title="author" class="post-info"><a href="mailto:lujun9972 &lt;at&gt; F31">lujun9972</a></span>
        </div>
    <script src="https://lujun9972.github.io/media/js/jquery-2.1.3.min.js"></script>
        <section>
            <h1>Comments</h1>
            <div id="comment-wrap">
                    <a class="disqus_label">使用 Disqus 评论</a>
    </ul>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
         //var disqus_developer = 1;
         var preempt_signal=false;
         var disqus_identifier = "/blog/2016/11/28/如何编写emacsscript/";
         var disqus_url = "https://lujun9972.github.io/blog/2016/11/28/如何编写emacsscript/";
         var disqus_shortname = 'lujun9972';
         /* * * DON'T EDIT BELOW THIS LINE * * */
         (function() {
             var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
             dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
             (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
             $('#disqus_thread').css('display','none');
         })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    <script>
     /* comments */
     var ego_disqus_thread=$('#disqus_thread');
     var ego_ds_label=$('.ds-thread');
     $('.disqus_label').click(function(){
         ego_disqus_thread.show();
         ego_ds_label.hide();
     });
     $('.ds-label').click(function(){
         ego_disqus_thread.hide();
         ego_ds_label.show();
     });
    </script>
        </section>
    <script src="https://lujun9972.github.io/media/js/main.js"></script>
    <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.x(<a href="http://orgmode.org">Org mode</a> 9.x)</p>
        <p>
            Copyright &copy; 2014 - <span id="footerYear"></span> <a href="mailto:lujun9972 &lt;at&gt; F31">lujun9972</a>
            &nbsp;&nbsp;-&nbsp;&nbsp;
            Powered by <a href="https://github.com/emacs-china/ego" target="_blank">EGO</a><br/>
            <a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" style="border-width:0" alt="Creative Commons License" class="center"></a>
            <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
    </div>
            </div>
            <script type="text/javascript"
                    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG">
            </script>
            <script type="text/x-mathjax-config">
             MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "AMS"} } });
            </script>
</div>

  </div></body>
</html>
